# MIRAGE-OG++ Artifact Guide

This repo is structured as a **paper artifact**: a runnable end-to-end demo + tests + a micro-benchmark.

## What You Can Reproduce (No External Keys)

1. Correctness + privacy plumbing (DPF/FSS-PIR, handles, MCP)
2. End-to-end allow/deny behavior for benign + malicious flows
3. A micro-benchmark showing **DPF key size is O(log N)** vs the old O(N) one-hot baseline

### Run

```bash
pip install -r requirements.txt
bash scripts/run_artifact.sh
```

Outputs are written to `artifact_out/`:

- `artifact_out/unittest.txt`
- `artifact_out/bench_fss.txt`
- `artifact_out/report.json` (machine-readable end-to-end result)
- `artifact_out/bench_e2e.json` (short end-to-end throughput numbers)
- `artifact_out/audit.jsonl` (gateway audit trail; JSONL)

## “Real Agent” Integration (NanoClaw Runtime)

NanoClaw uses the **Claude Agent SDK** runtime. This repo includes a small runner that exercises `mirage.act` via **MCP** from that runtime.

### Requirements

- Node.js 20+ (your machine already has Node if `node -v` works)
- One of:
  - `ANTHROPIC_API_KEY` (recommended), or
  - `CLAUDE_CODE_OAUTH_TOKEN`

### Run

```bash
# Optional: fetch upstream nanoclaw (pinned commit recorded in NANOCLAW_VERSION.txt)
bash scripts/setup_nanoclaw.sh

# Run the MCP-connected agent via Claude Agent SDK
export ANTHROPIC_API_KEY="..."
bash scripts/run_nanoclaw.sh
```

Notes:

- `scripts/run_nanoclaw.sh` starts: policy servers + executor, then runs
  `integrations/nanoclaw_runner/mirage_demo.mjs` (Claude Agent SDK runtime).
- This step makes external model calls; it is not required for the core artifact
  and is intentionally separated from `scripts/run_artifact.sh`.

## “Real Agent” Integration (OpenClaw + OpenAI OAuth)

If you want to validate the same protections using **OpenAI OAuth** (via OpenClaw's `openai-codex` provider), run:

```bash
bash scripts/setup_openclaw.sh

# Authenticate once with Codex CLI, then import the OAuth tokens into OpenClaw state.
# (scripts/run_openclaw.sh will also auto-import if auth is missing.)
OPENCLAW_STATE_DIR="artifact_out/openclaw_state" \
  python scripts/import_codex_oauth_to_openclaw.py

# Run benign + malicious scenarios; outputs are written to artifact_out/
bash scripts/run_openclaw.sh
```

Outputs:

- `artifact_out/openclaw_benign.json`
- `artifact_out/openclaw_malicious.json`

Notes:

- This step makes external model calls and is intentionally separated from `scripts/run_artifact.sh`.
- The OpenClaw config generated by `scripts/run_openclaw.sh` restricts core tools to a minimal set and exposes **only one side-effect tool**: `mirage_act` (a bridge to the Python MIRAGE MCP gateway).
- OpenClaw requires `node >= 22.12.0`.
- We intentionally do not rely on `openclaw models auth login --provider openai-codex` here, because that flow needs provider plugins; importing from `~/.codex/auth.json` is deterministic for the artifact.

## Optional: Rust Policy Server Backend

If you have a Rust toolchain available, you can switch policy servers to the compiled backend:

```bash
POLICY_BACKEND=rust bash scripts/run_artifact.sh
```

## Optional: Hide `db_name` (Policy Bundle)

To hide which logical DB is queried from each policy server, build a bundled DB and enable it in the gateway:

```bash
POLICY_BUNDLE_ENABLE=1 USE_POLICY_BUNDLE=1 bash scripts/run_artifact.sh
```
